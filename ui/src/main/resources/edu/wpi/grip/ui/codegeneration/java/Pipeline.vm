#if("${packageName}" != "")package ${packageName};

#end
#set($needsRefClass = false)
#set($lines = false)
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.HashMap;

#if($implementVisionPipeline)
import edu.wpi.first.wpilibj.vision.VisionPipeline;

#end
import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;

/**
* $className class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class $className #if($implementVisionPipeline)implements VisionPipeline #end{

	//Pipeline values for cv methods
	private HashMap<String, Object> params = new HashMap<>();

	//Is pipeline mutable
	private boolean isMutable = true;
	
	/**
	 * Initilize pipeline value
	 * @param name name of value
	 * @param val 
	 */
	public void initParam(String name, Object val) {
		params.put(name, val);
	}

	/**
	 * Accessor for single parameter
	 * @param name name of parameter
	 * @return {@code Object} with parameter value
	 */
	public Object getParam(String name) {
		if(isMutable) updateParams();
		return params.get(name);
	}

	/**
	 * Accessor for all parameter names
	 * @return {@code Set<String>} of all parameter names
	 */
	public Set<String> getParamNames() {
		return params.keySet();
	}

	//Outputs
#foreach($step in $pipeline.getSteps())
#foreach($out in $step.getOutputs())
	private #socketType(${out.type()}) ${tMeth.name($out.name())}#if(!$out.mutable()) = new #socketType(${out.type()})()#end;
#end
#end

#if($pipeline.getMovingThresholds().size() gt 0)

	//Moving Thresholds
#end
#foreach($moving in $pipeline.getMovingThresholds())
    private Mat lastImage$moving.num() = new Mat();
#end
#foreach($step in $pipeline.getSteps())
#if($step.name() == "Switch" || $step.name() == "Valve")
#set($boolInp = $step.getInput(0))
#set($boolName = "$tMeth.name($boolInp.name())")
	private boolean $boolName#if($boolInp.hasValue()) = $boolInp.value()#end;
#end
#end
	
#if(!$testing)
	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}#end


	//Pipeline JSON name
	private static final String configFile = "${className}Params.json";
	
	//Pipeline JSON root directory
	private static final String configDir = "/home/pi/pipeline-params/";
	
	//Full Pipeline JSON file path
	private static final String configFPath = configDir + configFile;

	/**
	 * This is a method that will retrieve updated pipeline values from the pipeline's JSON file
	 */
	private void updateParams() {
		Path fpath = Paths.get(configFPath);
		JsonElement top;
		try {
			//Read JSON
			top = new JsonParser().parse(Files.newBufferedReader(fpath));
			if(!top.isJsonObject()) {
				Files.deleteIfExists(fpath);
				throw new IOException();
			}
			JsonObject obj = top.getAsJsonObject();
			//Set Parameter Map To Values in JSON
			this.params = new Gson().fromJson(obj, HashMap.class);
		} catch(IOException ioe) {
			System.out.println("Could not update pipeline parameters");
			this.isMutable = false;
		}
	}

	/**
	 * Default constructor sets pipeline to mutable by default
	 */
	public $className() { this(true); }

	/**
	 * Constructor 
	 */
	public $className(boolean isMutable) {

		//JSON path
		Path fpath = Paths.get(configFPath);

		//JSON dir
        Path fdir = Paths.get(configDir);

		//Is pipeline mutable
		this.isMutable = isMutable;

		//Read JSON
		JsonElement top;
		try {
			top = new JsonParser().parse(Files.newBufferedReader(fpath));
			if(!top.isJsonObject()) {
				Files.deleteIfExists(fpath);
				throw new IOException();
			}
			JsonObject obj = top.getAsJsonObject();
			//Set Parameter Map To Values in JSON
			this.params = new Gson().fromJson(obj, HashMap.class);
		} catch(IOException ioe) {
			//If JSON does not exist
			try {
				//Init default pipeline values
#foreach($step in $pipeline.getSteps())
#configInput($step)
#end
				//Create JSON dir/file
				if(!Files.isDirectory(fdir)) Files.createDirectory(fdir);
                if(!Files.exists(fpath)) Files.createFile(fpath);
				//Write default values
				Files.write(fpath, new Gson().toJson(this.params).getBytes(StandardCharsets.UTF_8));
			} catch (Exception e) {
				System.out.println("New File Could Not Be Created - Pipeline Will Continue Running");
			}
		}

	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
#if($implementVisionPipeline)
	@Override#end
	public void process(#foreach($source in $pipeline.getSources())#socketType(${source.type()}) ${source.value()}#if($pipeline.getSources().indexOf($source) lt $pipeline.getSources().size() - 1), #end#end) {
#foreach($step in $pipeline.getSteps())
		// Step $step.name()$step.num():
#parse("$vmLoc/CVStep.vm")

#end
	}

#foreach($step in $pipeline.getSteps())
#if($step.name() == "Switch" || $step.name() == "Valve")
#set($boolInp = $step.getInput(0))
#set($boolName = "$tMeth.name($boolInp.name())")
#if($boolInp.hasValue())
	/**
	 * This method is a generated setter for the condition of $step.name()
	 * @param the condition to set
	 */
	 public void set$tMeth.name($step.name())$step.num()(boolean value) {
	 	$boolName = value;
	 }

#end
#end
#end
#foreach($step in $pipeline.getSteps())
#foreach($output in $step.getOutputs())
	/**
	 * This method is a generated getter for the output of a $step.name().
	 * @return #socketType(${output.baseType()}) output from $step.name().
	 */
	public #socketType(${output.baseType()}) ${tMeth.getterName($output.name())}() {
		return ${tMeth.name($output.name())};
	}

#end
#end

#foreach($step in $pipeline.getUniqueSteps())
#set($toParse = "$vmLoc/operations/" + $step.name())
#set($toParse = $toParse + ".vm")
#parse($toParse)


#end

#if($needsRefClass)
#parse("$vmLoc/Ref.vm")
#end


}
